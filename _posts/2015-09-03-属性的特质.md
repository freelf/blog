---
layout: post
title:  属性的特质
date:   2015-09-03 14:36:23
tags: 读书笔记
categories: iOS
---
​    最近读了Effective Objective-C。开篇就当做一篇笔记吧。在使用属性的时候，我们需要注意一个问题，就是属性的各种特质（attribute）设定也会影响编译器所生成的存取方法，下面这行代码，相必大家都很熟悉了。这行代码就指定了三项特质。
<!-- more -->

```
@property (nonatomic,readwrite,copy) NSString *firstName;
```

​         属性可以拥有的特质分为四类，下面为大家逐一讲解：

- 原子性

  在默认情况下，右边一起所合成的方法会通过锁定机制确保其原子性（atomic）。如果属性具备nonatomic特质，就不使用同步锁。请注意，如果没有声明nonatomic，这个属性就是atomic。若是自己定义存取方法，那么就应该遵从与属性特质相符的原子性。

- 读/写权限

  1.具备readwrite特质的属性拥有setter方法和getter方法，若是属性有`@syntehsize`实现，则编译器会自动生成这两个方法。

  2.具备readonly特质的属性仅仅拥有getter方法，只有当该属性有`@synthesize`实现时，编译器才会为其合成getter方法。你可以用此特质把某个属性对外公开为只读属性，然后在“class-continuation分类”中将其重新定义为读写属性。后面将详细叙述这种做法

- 内存管理语句

  属性用于封装数据，而数据则要有具体的所有权予以，下面这组特质仅仅会影响setter方法。例如，用setter方法设定一个新值时，它是应该retain此值呢，还是只将其赋值给底层的实例变量就好呢？编译器在合成存取方法时，要根据此特性来决定生成的代码。如果自己编写存取方法，那么就必须同有关属性所具备的的特质相符。

  1. assign  setter方法只会执行对基本类型的简单赋值操作。
  2. strong  此特质表明该属性定义了一种拥有关系，为这种属性设置新值时，setter方法会先保留新值，并释放旧值，然后再将新值设置上去
  3. weak    此特质表明该属性定义了一种非拥有关系，为这种属性设置新值时，setter方法既不保留新值，也不是放旧值。此特质同assign类似，然而在属性所指的对象遭到摧毁时，属性值也会清空。
  4. unsafe\_unretained   此特质语义和assign相同，但是它适用于对象类型，该特质表达一种非拥有关系，当目标对象遭到摧毁时，属性值不会自动置空，这一点与weak有区别。
  5. copy   此特质所表达的所属关系与strong类似。但是setter方法并不保留新值，而是将其copy。当属性类型为NSString\*时，经常用此特质来保护其封装性。因为传递给setter方法的新值可能指向一个NSMutableString类的实例。这个类是NSString的子类，表示一种可以修改的字符串，此时若不拷贝字符串，那么设置完属性后，字符串的值就肯呢个在对象不知情的情况下遭人修改。所以要拷贝一份不可变的字符串，确保对象中的字符串的值不会无意间变动。只要实现属性所用的对象是可变的，就应该设置新值时拷贝一份。

- 方法名

  可以通过如下特质指定存取方法的方法名：

  1. getter = <name> 指定getter方法的名字，如果某属性是bool类型，而你想在其getter方法加上is前缀，就可以通过这个办法来指定。

	 ```objective-c
	  @property (nonatomic, assign,getter=isOn) BOOL on;
	 ```

	 ​

  2. setter = <name> 指定setter方法的名字，这种用法不太常见

---- 

  ​        如果在其他的方法中设置属性值，那么同样需要遵守属性定义中所宣称的特性。例如我们扩充一下前面的Person类，如下图：

  ```objective-c
  @interface Person : NSObject
  @property(copy) NSString *firstName;
  @property(copy) NSString *lastName;
  -(id)initWithFirstName:(NSString *)firstName
                  lastName:(NSString *)lastName;
  @end
  ```

  ​        我们为其增加了一个初始化方法，那么在.m文件中实现这个初始化方法中，一定要遵循属性定义中的copy语义，初始化方法的实现代码应该这样写：

  ```objective-c
  -(id)initWithFirstName:(NSString *)firstName lastName:(NSString *)lastName{
      if ((self = [super init])) {
          _firstName = [firstName copy];
          _lastName  = [lastName copy];
      }
      return self;
  }
  ```

  ​        也许你们会问，为何不调用对应的setter方法呢，如果调用了setter方法，不是总能保证准确的语义么。我么将在下一篇中解释为什么绝不应该在init（或者dealloc）方法中调用存取方法。

  ​         atomic 和nonatomic的区别是什么呢？前面说过，具备atomic特质的getter方法会通过锁定机制来确保其原子性。这也就是说，如果两个线程读写同一属性，那么不论何时，总能看到有效的属性值。如果不加锁的话，那么其中一个线程正在改写某一个属性值时，另一个线程也许会突然闯入，把尚未修改好的属性值，读出来。发生这种情况时，线程读到的属性值可能不对。

  ​         开发iOS程序，你就会发现，其中所有属性都声明为nonatomic。这样做的历史原因是：在iOS中使用同步锁的开销较大，这样带来性能问题。一般情况下并不要求属性必须是atomic，因为这并不能保证线程安全，若要实现线程安全的操作，还需采用更为深层的锁定机制才行，例如，一个线程连续多次读取某属性值得过程中有别的线程同事改写该值，那么即便将属性声明为atomic，也还是会读到不同的属性值。因此，开发iOS程序时，一般都会使用nonatomic属性。

  ​         下面我们总结下：

  1. 可以通过`@property`语法定义对象中所封装的数据。

  2. 通过属性的特质来指定存储数据所需的正确语义。

  3. 在设置属性对应的实例变量时，一定要遵从该属性所声明的语义。

  4. 开发iOS程序应使用nonatomic属性，因为atomic属性严重影响性能。

	 ​        今天就写到这里，下一篇我们将讲解下在对象内部访问实例变量到底应该通过属性访问，还是直接访问实例变量呢？


