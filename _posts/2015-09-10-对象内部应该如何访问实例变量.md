---
layout: post
title:  "对象内部应该如何访问实例变量"
date:   2015-09-10 15:26:23
tags: 读书笔记
categories: iOS    
---
​          在上一篇中，我们讲解了一些属性的特质，接下来我们讲下访问实例变量的问题，在对象之外访问实例变量时，总是应该通过属性来做，那么在对象内部访问实例变量又该如何呢？OC的开发者一直在激烈的讨论这些问题。有的人认为，无论什么情况都应该使用属性访问实例变量，也有人说通过属性访问和直接访问应该搭配着使用。除了集中特殊情况外，在这里建议大家在读取实例变量时采用直接访问，在设置实例变量时通过属性来做。
<!-- more -->
​           请看下面这个类:

```objective-c
@interface Person : NSObject
@property(nonatomic, copy) NSString *firstName;
@property(nonatomic, copy) NSString *lastName;
-(NSString *)fullName;
-(void)setFullName:(NSString *)fullName;
@end

```

```objective-c
@implementation Person
-(NSString *)fullName{
    return [NSString stringWithFormat:@"%@ %@",self.firstName,self.lastName];
}
-(void)setFullName:(NSString *)fullName{
    NSArray *components = [fullName componentsSeparatedByString:@" "];
    self.firstName = [components objectAtIndex:0];
    self.lastName  = [components objectAtIndex:1];
}
@end

```

​       在fullName的获取方法中，我们使用点语法，通过属性访问实例变量，现在假设重写上面两个方法不经由存取方法，而是直接访问实例变量

```objective-c
@implementation Person
-(NSString *)fullName{
    return [NSString stringWithFormat:@"%@ %@",_firstName,_lastName];
}
-(void)setFullName:(NSString *)fullName{
    NSArray *components = [fullName componentsSeparatedByString:@" "];
    _firstName = [components objectAtIndex:0];
    _lastName  = [components objectAtIndex:1];
}
@end
```

​         这两种方法的区别是：

- 由于不经过OC的“方法派发”步骤，所以直接访问实例变量的速度当然比较快，在这种情况下，编译器所生成的代码会直接访问保存对象实例变量的那块内存。

- 直接访问实例变量时，不会调用其setter方法，这就绕过了为相关属性所定义的“内存管理语句”。比方说，如果在ARC下直接访问一个声明为copy的属性，那么并不会拷贝该属性，只会保留新值释放旧值。

- 如果直接访问智力变量，那就不会触发KVO通知，这样做是否会有问题，还取决于具体的对象行为。

- 通过属性来访问有助于排查与之相关的错误，因为可以给setter/getter方法增加断点，监控该属性的调用者及其访问时机。

  ​        有一种折中的方案就是，在写入实例变量时，通过其setter方法来做，而在读取实例变量时，则直接访问。此办法既能提高读取操作的速度，又能控制对属性的写入操作。之所以要通过setter方法来写入实例变量，其首要原因在于，这样做能够确保相关属性的“内存管理语句”得到贯彻，但是选用这种做法时，须注意几个问题。

  ​         第一个需要注意的问题是，在初始化方法中应该如何设置属性值。这种情况下应该直接访问实例变量，因为子类可能会覆写设置方法。假设Person有一个叫做SmithPerson的子类，这个子类专门表示那些姓“Smith”的人，该子类可能会覆写lastName属性所对应的设置方法：

  ```objective-c
  -(void)setLastName:(NSString *)lastName{
      if (![lastName isEqualToString:@"Smith"]) {
          [NSException raise:NSInvalidArgumentException format:@"last name must be Smith"];
      }
      self.lastName = lastName;
  }
  ```

  ​         在父类Person的默认初始化方法中，可能会将lastName设为空字符串。此时若是通过setter方法来做，那么调用的将是子类的设置方法，从而抛出异常。但是，在某些情况下却又必须在初始化方法中调用setter方法：如果待初始化的实例变量声明在超类中，而我们又无法在子类中直接访问此实例变量的话，就需要调用setter方法了。

  ​          另外还需要注意的问题是“懒加载”。在这种情况下，必须通过getter方法来访问属性，否则，实例变量永远不会初始化。比如说：在Person类中有一个描述人脑信息的实例变量，这个属性所指的对象比较复杂。由于此属性不常用，，而且创建的成本比较高。我们就会在其getter方法中对其惰性初始化：

  ```objective-c
  -(Brain *)brain{
      if (!_brain) {
          _brain = [Brain new];
      }
      return _brain;
  }
  ```

  ​         若没有调用getter方法就直接访问实例变量，就会看到尚未设置好的brain，所以如果是“懒加载”，那么必须通过存取方法来访问brain属性。

  ​        今天就到这里了，下面总结下：

  - 在对象内部读取数据时，应该直接通过实例变量来读，而写入数据时，则应该通过属性来写。
  - 在初始化方法和dealloc方法中，总是应该直接使用实例变量来读写数据。
  - 使用懒加载配置某些数据时，需要通过属性来读取数据。

