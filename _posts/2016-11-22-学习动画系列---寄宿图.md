---
layout: post
title: 学习动画系列---寄宿图
date:   2016-11-22 11:54:36
tags: Core Animation
categories: iOS                      
---
&emsp;&emsp;上一篇学习了下`CALayer`的概念，者一篇学习下`CALayer`的内部属性，我们先来解释下什么是寄宿图。在上一篇中，我们通过`CALayer`类创建了一个蓝色的背景图层，如果他仅仅是展现一个单调的颜色，\~\~那我还学他干啥？\~\~其实它还可以包含一张图片，它里面包含的图我们就叫寄宿图。这个名字太奇怪了。估计是翻译的问题吧。
<!-- more -->
# contents属性
## contents
&emsp;&emsp;`CALayer`有个`contents`属性，这个属性被定义为id类型，但是可不要被定义为id类型迷惑，如果给`contents`属性赋的值不是CGImage，那么他就是一个空白的layer。

&emsp;&emsp;这个奇怪的表现实由于Mac OS的历史原因造成的，因为在Mac OS中，这个属性对CGImage和NSImage都有作用。如果在iOS平台上将UIImage的值赋给它，只能得到一个空白的layer。

&emsp;&emsp;事实上，我们真正要赋值的是一个CGImageRef的指针，UIImage有个CGImage的属性，返回一个CGImageRef，如果我们直接把这个值赋给`contents`，编译器会提醒我们需要加上(\_\_bridge id)，这是为啥呢，因为CGImageRef是一个Core Foundation类型的。因为Core Foundation对象和Cocoa对象在运行时是toll-free bridging的，所以我们可以通过\_\_bridge关键字转换的。所以我们用下面的代码就可以让一个view现实一个图片，是不是很神奇。算了，当我没说。还是看代码吧：


```objective-c
    UIImage *image = [UIImage imageNamed:@"Slice1.png"];
    _backView.layer.contents = (__bridge id)image.CGImage;
```

&emsp;&emsp;通过上面的代码，我们可以实现如下图所示的效果：


<span><img src="\images\寄宿图\1.png"></span>

&emsp;&emsp;用这些简单的代码做了一件非常有趣的事情，就是我们利用`CALayer`在一个普通的`UIView`中显示了一个图片，而不是用UIImageView。通过操作`CALayer`可以让`UIView`更加有趣啦。哈哈哈！

## contentGravity

&emsp;&emsp;这个属性对应的是`UIView`的contentMode属性。但是它是一个`NSString`类型，contentGravity可选的常量值有一下这些：

* kCAGravityCenter
* kCAGravityTop
* kCAGravityBottom
* kCAGravityLeft
* kCAGravityRight
* kCAGravityTopLeft
* kCAGravityTopRight
* kCAGravityBottomLeft
* kCAGravityBottomRight
* kCAGravityResize
* kCAGravityResizeAspect
* kCAGravityResizeAspectFill

和`UIView`的那些属性是对应的。

## contentsScale

&emsp;&emsp;contentsScale属性定义了寄宿图的像素尺寸和视图大小的比例，默认情况下它是1.0。contentsScale属性其实是适配Retina屏幕的，如果他的值为1.0，那么一个点绘制一个像素，如果为2.0，那么一个点绘制2个像素。所以当用代码手动处理寄宿图的时候，一定要记住手动设置图层的contentsScale属性，否则，你的图片在Retina屏幕上面就显示的不对啦！

## maskToBounds

&emsp;&emsp;这个属性对应`UIView`的clipsToBounds的属性，它可以用来决定是否显示超出边界的内容，把它设置为YES，图片就不会超出边界绘制了。

## contentsRect

&emsp;&emsp;`CALayer`的contentsRect属性允许我们再图层边框里显示寄宿图的一个子区域。这涉及到图片是如何显示和拉伸的，所以比contentsGravity灵活多了，和`bounds`、`frame`不同，这个属性不是按点来计算的，它使用了单位坐标。单位坐标是指定在0\~1之间的。是一个相对的值。讲到这个，就有必要介绍下iOS使用的坐标系统了。

* 点--在iOS和Mac OS中最常见的坐标体系。点就像是虚拟的像素，也被称作逻辑像素。在标准设备上，一个点就是一个像素，但是在Retina设备上，一个点等于2\*2个像素。iOS用电作为屏幕的坐标测算体系就是为了在Retina设备和普通设备能有一致的视觉效果。
* 像素--物理像素坐标不会用来屏幕布局，但是仍然与图片有相对关系。UIImage是一个屏幕分辨率解决方案，所以指定点来度量大小。但是一些底层的图片表示如CGImage就会使用像素，所以你要清楚再Retina设备和普通设备上，他们表现出来了不同的大小。
* 单位--对于与图片大小或是图层边界相关的显示，单位坐标是一个方便的度量方式，当大小改变的时候，也不需要再次调整。单位坐标在OpenGL这种纹理坐标系统中用得很多，Core Animation中也用到了单位坐标。

默认的contentsRect是{0,0,1,1}，这意味着整个寄宿图都默认都是可见的，如果我们指定一个小一点的矩形，图片就会裁剪，这个我们可以自己去代码试验下。

&emsp;&emsp;事实上给contentsRect设置一个负数的原点或者是大于{1,1}的尺寸也是可以的。这种情况下，最外面的像素会被拉伸以填充剩下的区域。

&emsp;&emsp;利用contentsRect可以把一大张图切成小图显示，下面我们用代码来显示下，首先我们需要载入一张大图：

<span><img src="\images\寄宿图\Slice1.png"></span>

我们怎么把这个大图分别裁成四个小图在app中显示呢，其实利用这个属性很简单。我们把这张大图赋值给四个独立的图层contents，然后设置每个layer的contentsRect来去掉我们不想要的部分。我们在StoryBoard上再拖四个view上来，然后看我们下面的代码：


```objective-c
- (void)viewDidLoad {
    [super viewDidLoad];
    UIImage *image = [UIImage imageNamed:@"Slice1.png"];
    _backView.layer.contents = (__bridge id)image.CGImage;
    
    [self addSpriteImage:image withContentRect:CGRectMake(0, 0, 0.5, 0.5) toLayer:_gaoyuanyuan.layer];
    
    [self addSpriteImage:image withContentRect:CGRectMake(0.5, 0, 0.5, 0.5) toLayer:_jiangshuying.layer];
    
    [self addSpriteImage:image withContentRect:CGRectMake(0, 0.5, 0.5, 0.5) toLayer:_sijiali.layer];
    
    [self addSpriteImage:image withContentRect:CGRectMake(0.5, 0.5, 0.5, 0.5) toLayer:_anji.layer];
}


- (void)addSpriteImage:(UIImage *)image withContentRect:(CGRect)rect toLayer:(CALayer *)layer //set image
{
    layer.contents = (__bridge id)image.CGImage;
   
    layer.contentsGravity = kCAGravityResizeAspect;

    layer.contentsRect = rect;
}

```

这样就实现了我们的效果：

<span><img src="\images\寄宿图\2.png"></span>

## contentsCenter

&emsp;&emsp;现在我们介绍的最后一个和内容有关的属性是contentsCenter，看这个名字可能会以为跟图片的中心点位置有关。不过这个名字误导了我们。contentsCenter其实是一个CGRect，它定义了一个固定的边框和一个在图层上可以拉伸的区域。改变了contentsCenter的值并不会影响到寄宿图的显示，除非这个图层的位置改变了你才看得到效果。怎么理解contentsCenter呢，看下面这个图就懂啦！

<span><img src="\images\寄宿图\3.png"></span>

&emsp;&emsp;其实在IB中也可以设置这个就是:

<span><img src="\images\寄宿图\4.png"></span>

# Custom Drawing

&emsp;&emsp;给contents设置CGImage不是唯一设置寄宿图的方法。我们还可以直接用Core Graphics直接绘制寄宿图。能够通过继承`UIView`并实现`-drawRect:`方法来绘制。

&emsp;&emsp;`-drawRect:`方法没有默认的实现，因为`UIView`并不在意寄宿图到底是单调的颜色还是图片，寄宿图并不是必须的。如果`UIView`检测到`-drawRect:`方法调用了，它就会给视图分配一个寄宿图，寄宿图的像素尺寸是视图大小乘以`contentsScale`的值。

&emsp;&emsp;如果我们不需要寄宿图，那就不要复写这个方法了，这回造成CUP资源和内存的浪费，这也是苹果为什么建议我们，如果没有自定义的绘制就不要在子类中写一个空的`-drawRect:`方法啦。

&emsp;&emsp;当视图在屏幕上出现的时候`-drawRect:`方法自动会调用。`-drawRect:`方法里面的代码利用了Core Graphics去绘制一个寄宿图，然后内容就会被缓存起来知道它需要被更新（通常是我们调用了`-setNeedsDisplay`方法，尽管影响到表现效果的属性值被更改时，一些试图类型会被自动重绘，如`bounds`属性）。虽然`-drawRect:`方法是一个UIView方法，事实上都是底层的CALayer安排了重绘工作和保存了因此产生的图片。

&emsp;&emsp;CALayer有一个可选的`delegate`属性，实现了`CALayerDelegate`协议，当CALayer需要一个内容特定的信息时，就会从协议中请求。CALayerDelegate是一个非正式协议，其实就是说没有CALayerDelegate @protocol可以让你在类里面饮用啦。你只需要调用你想调用的方法，CALayer会帮你做剩下的。

&emsp;&emsp;当需要被重绘时，CALayer会请求它的代理给它一个寄宿图来显示。它通过调用下面这个方法做到的：

```objective-c
-(void)displayLayer:(CALayerCALayer *)layer;
```

&emsp;&emsp;趁这个机会，如果代理想直接设置contents属性的话，他就可以这么做，不然没有别的方法可以调用了。如果代理不实现`-displayLayer:`方法，CALayer就会转而尝试调用下面这个方法：

```objective-c
- (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx;
```

&emsp;&emsp;在调用这个方法之前，CALayer创建了一个合适尺寸的空寄宿图（尺寸有bounds和contentsScale决定）和一个Core Graphics的绘制上下文环境，为绘制寄宿图做准备，他作为ctx参数传入。

&emsp;&emsp;让我们用代码来看一下他的作用：


```objective-c
- (void)viewDidLoad {
    [super viewDidLoad];
   CALayer *backLayer = _backView.layer;
    
    CALayer *blueLayer = [CALayer layer];
    
    blueLayer.backgroundColor = [UIColor blueColor].CGColor;
    
    blueLayer.frame = CGRectMake(0, 0, 100, 100);
    
    blueLayer.contentsScale = [UIScreen mainScreen].scale;
    
    blueLayer.delegate = self;
    
    [backLayer addSublayer:blueLayer];
    
    [blueLayer display];
}
    -(void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx
{
    
    CGContextSetLineWidth(ctx, 10.0f);
    CGContextSetStrokeColorWithColor(ctx, [UIColor redColor].CGColor);
    CGContextStrokeEllipseInRect(ctx, layer.bounds);
}

```

通过上述代码就可以实现下图的效果：

<span><img src="\images\寄宿图\5.png"></span>

注意一些东西：

* 我们再blueLayer上显示的调用了`-display`。不同于UIView，当图层显示在屏幕上时，CALayer不会自动重绘它的内容。它把重绘的决定权交给了开发者。
* 尽管我们没有用`masksToBounds`属性，绘制的那个圆依然沿边界被剪裁了，这是因为你当你使用CALayerDelegate绘制寄宿图的时候，并没有对超出边界外的内容提供绘制支持。

&emsp;&emsp;现在我们理解了CALayerDelegate，并知道怎么使用它。但是除非我们自己创建了一个单独的图层，几乎没有机会用到CALayerDelegate。因为当UIView创建了它的宿主图层时，它就自动把图层的delegate设置成自己了，并切提供了一个`-displayLayer:`的实现，那所有问题都没有了。

&emsp;&emsp;当使用寄宿了视图的图层的时候，我们也不必实现`-displayLayer:`和`-drawLayer:inContext:`方法来绘制我们的寄宿图。通常做法是实现UIView的`-drawRect:`方法，UIView会帮我们做完剩下的工作，包括在需要重绘时执行`-display`方法。

&emsp;&emsp;好啦，终于又看完了一章，坚持！！

























