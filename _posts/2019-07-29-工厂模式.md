---
layout: post
title: 工厂模式
date: 2019-07-29 11:16:52
tags: 设计
category: 设计模式
---

最近重新学习设计模式，以前一直看的是Raywenderlich的书籍，总感觉不够深入。最近重新找了一本书来学习，所以以前的系列就不再继续写了，重新开始记录。这是第一篇，来学习一下工厂模式。
设计模式名字中带工厂的有三个。简单工厂，工厂方法，抽象工厂。本文就看一下这三种工厂的区别，以及从简单工厂到抽象工厂的演进。
## 简单工厂
严格来讲简单工厂并不是一个标准的设计模式，但是它太常用了，所以需要我们好好掌握它。

在讲简单工厂前，我们先来讲一下接口(在iOS中叫做协议)。以前看任何有关设计的书时，总是会提到面向接口编程这个概念。那么接口是什么呢？接口有什么用？如何使用接口呢？下面我们先来搞明白这些问题再去学习简单工厂。
那么接口是什么呢？总的来说接口就是对一组实现的抽象，描述一个实现对象应有的一些功能。

至于接口有什么用呢？根据接口的定义，我们可以看出来，接口就是来定义实现的外观。用来约束实现类的行为，接口相当于一份契约，根据外部应用需要的功能，约定了实现类要实现的功能。但是具体的实现类除了实现接口定义的功能也可以实现一些其他的功能。

那么如何使用接口呢？接口的作用和用途浓缩下来就一句话，**封装隔离**。以前通常提到的封装是对数据的封装。我们这里的封装指的是对实现对象的行为和职责的封装。隔离是指外部调用和内部实现，外部调用只能通过接口调用，外部调用是不知道内部实现的，也就是说外部调用和内部实现是被接口隔离开的。

使用接口的好处就是只要接口不变，内部的实现无论如何变化，外部调用都不会改变。从而使得系统更加灵活，具有更好的可扩展性和可维护性。所以设计的书中一直强调面向接口编程。
### 场景问题
接口的概念回忆完了，我们来看一下平常我们是如何使用接口的。假设有一个接口名字叫做`Api`,然后有一个实现类`Imp`实现了它，在客户端如何使用这个接口呢？通常情况下我们都会在客户端创建一个`Imp`对象，然后把它赋值给一个`Api`接口类型的变量。我们用代码来表示一下，因为我自己是一个iOS开发，所以代码使用Objective-C来体现：
```objc
// Api
@protocol Api <NSObject>
- (void)doSomething;
@end

// Imp
@interface Imp : NSObject<Api>

@end

@implementation Imp

- (void)doSomething {
	NSLog(@"doSomething");
}

@end

// 使用接口
int main () {
	id<Api> api = [Imp new];
	[api doSomething];
}
```
上面代码有什么问题呢？我们发现在使用接口的时候，我们既知道了`Api`又知道了`Imp`。接口的作用不是为了隔离外部调用和内部实现么，这里并没有隔离。为了隔离调用和实现，我们可以使用简单工厂来解决。
### 简单工厂的使用
> 提供一个创建对象实例的功能，而无需关心其具体实现。

我们可以通过提供一个创建对象实例的类给客户端，让客户端通过这个类来获取实例。减少了客户端和具体实现的依赖。下面我们通过代码来看一下通过简单工厂是如何解决问题的：
```objc
// Api
@protocol Api <NSObject>
- (void)doSomething;
@end

// ImpA
@interface ImpA : NSObject<Api>

@end

@implementation ImpA

- (void)doSomething {
	NSLog(@"ImpA doSomething");
}

@end

// ImpB
@interface ImpB : NSObject<Api>

@end

@implementation ImpB

- (void)doSomething {
	NSLog(@"ImpB doSomething");
}

@end

// Factory
@interface Factory : NSObject

@end

@implementation Factory

- (id<Api>)createImpWithCondition:(Int)condition {
	if (condition == 1) {
		return [ImpA new];
	} else if (condition == 2) {
		return [ImpB new];
	}
}
@end

// 使用接口
int main () {
	id<Api> api = [Facotry createImpWithCondition:1];
	[api doSomething];
}
```
###  存在的问题
如果在上述例子中，我们再添加一种实现，需要改动`Factory`的实现。每次添加一个新的实现都需要去修改工厂类，这显然不是一个好的实现方式。那么该怎么办呢。我们可以利用反射去实现，这里我们需要一个配置文件，Objective-C中最简单的配置文件就是plist，我们可以创建一个plist去配置实现类，然后再创建实现时去读plist中的配置，利用`NSClassFormString`方法获取`Class`，然后创建具体的实现类。以后添加新的实现时，我们只需要修改plist文件即可。
### 思考简单工厂
简单工厂的本质就是**选择实现**，重点在于选择，实现是提前写好的，就算是再简单的实现也要在实现类里面实现，不能在工厂类里面实现。简单工厂的目的在于为客户端选择实现，从而使客户端和实现解耦，如果具体实现发生了变化就不用变动客户端了，变化会被简单工厂吸收和屏蔽掉。可以看到简单工厂主要就是为了减少依赖，具体逻辑由具体类负责。
## 工厂方法
考虑这样一个实际应用，我们要实现一个导出数据的应用框架，让客户端选择数据的导出方式，然后导出数据。导出数据可能是文本格式，可能是数据库格式，也可能是PDF格式。
### 场景问题
分析上面的实现，不管用户选择什么样的导出方式，最后导出的都是一个文件，因此应该有一个接口来描述导出文件对象的功能。我们把这个接口名叫做`ExportFileApi`，对于实现导出数据业务的功能对象，我们把它叫做`ExportOperate`。他应该根据需要来创建对应的`ExportFileApi`实现对象，但是`ExportOperate`并不知道应该创建哪一个`ExportFileApi`，也不知道如何创建`ExportFileApi`，因为`ExportOperate`只知道`ExportFileApi`这个接口，并不知道具体实现对象。
### 使用工厂方法解决问题
> 定义一个用于创建对象的接口，让子类决定实例化哪一个类，工厂方法使一个类的实例化延迟到子类。

下面我们看一下使用具体代码如何解决上面这个问题的。我们先定义一下`ExportFileApi`这个接口：
```objc
@protocol ExportFileApi <NSObject>

/**
 导出数据到文件

 @param data 被导出的数据
 @return 是否导出成功
 */
- (BOOL)exportFileWithData:(NSData*)data;
@end
```
我们先提供导出两种文件，分别是文本格式和数据库格式：
```objc
// 导出为文本的实现类
@interface ExportTxt : NSObject<ExportFileApi>

@end

@implementation ExportTxt

- (BOOL)exportFileWithData:(NSData *)data {
	NSLog(@"导出为文本");
	return YES;
}
@end

//导出为DB的实现类
@interface ExportDB : NSObject<ExportFileApi>

@end
@implementation ExportDB
- (BOOL)exportFileWithData:(NSData *)data {
	NSLog(@"导出为DB");
	return YES;
}
@end
```

具体导出数据业务的功能对象`ExportOperate`示例代码如下：
```objc
@interface ExportOperate : NSObject
- (BOOL)exportFileWithData:(NSData *)data;
/**
 创建导出文件的具体实现

 @return 导出文件的具体实现
 */
- (id<ExportFileApi>)factoryMethod;
@end

@implementation ExportOperate

- (BOOL)exportFileWithData:(NSData *)data {
	id<ExportFileApi> api = [self factoryMethod];
	return [api exportFileWithData:data];
}
- (id<ExportFileApi>)factoryMethod {
	[NSException exceptionWithName:@"抽象方法不能直接调用" reason:@"必须子类重写" userInfo:nil];
	return nil;
}
@end
```
下面我们加入两个导出操作，一个是导出文本文档的操作，一个是导出数据库的操作。
```objc
// 导出文本文档的操作
@interface ExportTxtOperate : ExportOperate

@end
@implementation ExportTxtOperate
- (id<ExportFileApi>)factoryMethod {
	return [ExportTxt new];
}
@end
// 导出DB的操作
@interface ExportDBOperate : ExportOperate

@end
@implementation ExportDBOperate
- (id<ExportFileApi>)factoryMethod {
	return [ExportDB new];
}
@end
```
客户端代码示例代码：
```objc
int main(int argc, char * argv[]) {
	ExportOperate *dbOperate = [ExportDBOperate new];
	[dbOperate exportFileWithData:[NSData data]];
	return 0;
}
```
还可以修改客户端new的对象，切换成其他的实现对象。此时如果增加新的导出类型的话，只需要继承`ExportOperate`再次重写工厂方法就好了。也可以参数化工厂方法，在父类里面提供默认实现。这里简单写一下：
```objc
@interface ExportOperate : NSObject
- (BOOL)exportFileWithData:(NSData *)data dataType:(NSInteger)type;
/**
 创建导出文件的具体实现

 @return 导出文件的具体实现
 */
- (id<ExportFileApi>)factoryMethodWithType:(NSInteger)type;
@end
@implementation ExportOperate

- (BOOL)exportFileWithData:(NSData *)data dataType:(NSInteger)type {
	id<ExportFileApi> api = [self factoryMethodWithType:type];
	return [api exportFileWithData:data];
}
- (id<ExportFileApi>)factoryMethodWithType:(NSInteger)type {
	if (type == 1) {
		return [ExportTxt new];
	} else if (type == 2) {
		return [ExportDB new];
	}
	return nil;
}
@end
```
客户端代码：
```objc
int main(int argc, char * argv[]) {
	ExportOperate *dbOperate = [ExportOperate new];
	[dbOperate exportFileWithData:[NSData data] dataType:1];
	[dbOperate exportFileWithData:[NSData data] dataType:2];
	return 0;
}
```
如果这时增加导出PDF的操作，只需要继承`ExportOperate`就可以：
```objc
@interface ExportPDFOperate : ExportOperate

@end
@implementation ExportPDFOperate

- (id<ExportFileApi>)factoryMethodWithType:(NSInteger)type {
	if (type == 3) {
		return [ExportPDF new];
	} else {
	   return [super factoryMethodWithType:type];
	}
}
@end
```
客户端代码不用变化：
```objc
int main(int argc, char * argv[]) {
	ExportOperate *dbOperate = [ExportOperate new];
	[dbOperate exportFileWithData:[NSData data] dataType:1];
	[dbOperate exportFileWithData:[NSData data] dataType:2];
	[dbOperate exportFileWithData:[NSData data] dataType:3];
	return 0;
}
```
### 思考工厂方法
工厂方法的本质是**延迟到子类来选择实现**，它和简单工厂非常类似，都是选择实现，但是也存在不同点。简单工厂是在工厂里面直接选择实现，而工厂方法会把这个工作延迟到子类去实现，工厂类里面使用工厂方法的地方是依赖于具体实现的接口，这样使代码更加灵活，具有更好的可扩展性和可维护性。如果把工厂类退化一下，只提供工厂方法，而且工厂方法提供默认实现，就变成简单工厂了。可以认为简单工厂就是工厂方法的一种特例，因为它们本质是类似的，都是选择实现。
## 抽象工厂
考虑一个生活中常见的例子——组装电脑，我们组装电脑时经常需要选择一些配件。其中主要的配件包括CPU，主板，内存等。为了简单点，我们只考虑CPU和主板。我们都知道CPU和主板需要配置好，不然会有不兼容的问题。对于装机工程师而言，他只知道要组装一台电脑，需要响应的配件，但是具体使用什么样的配件，需要客户说了算。现在我们来实现一下这个程序。
### 场景问题
对于装机工程师而言，只要知道CPU和主板的接口，不知道具体实现，很明显可以用上简单工厂和工厂模式，为了简单，我们这里选择简单工厂。客户告诉装机工程师自己的选择，然后装机工程师会通过相应的工厂去获取相应的实例对象。示例代码如下：
```objc
// CPU接口
@protocol CPUApi <NSObject>

- (void)calculate;

@end

// 主板接口
@protocol MainBoardApi <NSObject>

- (void)installCPU;

@end

// Intel的CPU实现
@interface IntelCPU : NSObject<CPUApi>
- (instancetype)initWithPins:(NSUInteger)pins;
@end

@interface IntelCPU ()
@property (nonatomic, assign) NSUInteger pins;
@end

@implementation IntelCPU
- (instancetype)initWithPins:(NSUInteger)pins {
	self = [super init];
	if (self) {
		self.pins = pins;
	}
	return self;
}
- (void)calculate {
	NSLog(@"IntelCPU pins = %zd", self.pins);
}
@end

// AMD的CPU实现
@interface AMDCPU : NSObject<CPUApi>
- (instancetype)initWithPins:(NSUInteger)pins;
@end
@interface AMDCPU ()

@property (nonatomic, assign) NSUInteger pins;

@end

@implementation AMDCPU
- (instancetype)initWithPins:(NSUInteger)pins {
	self = [super init];
	if (self) {
		self.pins = pins;
	}
	return self;
}
- (void)calculate {
	NSLog(@"AMDCPU pins = %zd", self.pins);
}
@end

// 技嘉主板实现
@interface GAMainBoard : NSObject<MainBoardApi>
- (instancetype)initWithCpuHoles:(NSUInteger)holes;
@end

@interface GAMainBoard ()
@property (nonatomic, assign) NSUInteger cpuHoles;
@end

@implementation GAMainBoard
- (instancetype)initWithCpuHoles:(NSUInteger)holes {
	self = [super init];
	if (self) {
		self.cpuHoles = holes;
	}
	return self;
}
- (void)installCPU {
	NSLog(@"GAMainBoard cpuHoles = %zd", self.cpuHoles);
}
@end

// 微星主板实现
@interface MSIMainBoard : NSObject<MainBoardApi>
- (instancetype)initWithCpuHoles:(NSUInteger)holes;
@end

@interface MSIMainBoard ()
@property (nonatomic, assign) NSUInteger cpuHoles;
@end

@implementation MSIMainBoard
- (instancetype)initWithCpuHoles:(NSUInteger)holes {
	self = [super init];
	if (self) {
		self.cpuHoles = holes;
	}
	return self;
}
- (void)installCPU {
	NSLog(@"MSIMainBoard cpuHoles = %zd", self.cpuHoles);
}
@end

// CPU工厂实现
@interface CPUFactory : NSObject
+ (id<CPUApi>)createCpuWithType:(NSUInteger)type;
@end

@implementation CPUFactory
+ (id<CPUApi>)createCpuWithType:(NSUInteger)type {
	if (type == 1) {
		return [[IntelCPU alloc]initWithPins:1156];
	} else if (type == 2) {
		return [[AMDCPU alloc]initWithPins:939];
	} else {
		return nil;
	}
}
@end

// 主板工厂实现
@interface MainBoardFactory : NSObject
+ (id<MainBoardApi>)createMainBoardWithType:(NSUInteger)type;
@end

@implementation MainBoardFactory
+ (id<MainBoardApi>)createMainBoardWithType:(NSUInteger)type {
	if (type == 1) {
		return [[GAMainBoard alloc]initWithCpuHoles:1156];
	} else if (type == 2) {
		return [[MSIMainBoard alloc]initWithCpuHoles:939];
	} else {
		return nil;
	}
}
@end

// 装机工程师的实现
@interface ComputerEngineer : NSObject
- (void)makeComputerWithCpuType:(NSUInteger)cpuType mainBoardType:(NSUInteger)mainBoardType;
@end

@interface ComputerEngineer ()
@property (nonatomic, strong) id<CPUApi> cpu;
@property (nonatomic, strong) id<MainBoardApi> mainBoard;
@end

@implementation ComputerEngineer
- (void)makeComputerWithCpuType:(NSUInteger)cpuType mainBoardType:(NSUInteger)mainBoardType {
	// 准备硬件
	[self prepareHardwaresWithCpuType:cpuType mainBoardType:mainBoardType];
	// 组装机器
	// 测试机器
}
- (void)prepareHardwaresWithCpuType:(NSUInteger)cpuType mainBoardType:(NSUInteger)mainBoardType {
	self.cpu = [CPUFactory createCpuWithType:cpuType];
	self.mainBoard = [MainBoardFactory createMainBoardWithType:mainBoardType];
	
	// 测试是否好用
	[self.cpu calculate];
	[self.mainBoard installCPU];
}
@end

// 测试
int main(int argc, char * argv[]) {
	ComputerEngineer *engineer = [ComputerEngineer new];
	[engineer makeComputerWithCpuType:1 mainBoardType:1];
}

// 运行结果如下
IntelCPU pins = 1156
GAMainBoard cpuHoles = 1156
```
看了上面的实现，会感觉很简单。但是有一个问题，就是CPU和主板对象必须兼容，比容上面例子中我们传入CPU的类型是1，主板类型是2，就会出现不匹配的情况。
### 抽象工厂的使用
我们可以使用抽象工厂来解决上面的问题。
> 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。

分析上面的问题，其实用两个问题点，一个是只知道所需要的一系列对象的接口，而不知道具体实现；另外一个是这一系列对象是相关或者相互依赖的。也就是说既要创建接口的对象，还要约束他们之间的关系。工厂方法和简单工厂关注的是单个产品对象的创建，抽象工厂专注的是一系列产品的创建。
下面我们使用抽象工厂来优化上面的例子：
```objc
// 抽象工厂
@protocol AbstractFactory <NSObject>
- (id<CPUApi>)createCpu;
- (id<MainBoardApi>)createMainboard;
@end

// 具体工厂1
@interface SchemaOne : NSObject<AbstractFactory>

@end
@implementation SchemaOne
- (id<CPUApi>)createCpu {
	return [[IntelCPU alloc]initWithPins:1136];
}
- (id<MainBoardApi>)createMainboard {
	return [[GAMainBoard alloc]initWithCpuHoles:1136];
}
@end

// 具体工厂2
@interface SchemaTwo : NSObject<AbstractFactory>

@end
@implementation SchemaTwo
- (id<CPUApi>)createCpu {
	return [[AMDCPU alloc]initWithPins:939];
}
- (id<MainBoardApi>)createMainboard {
	return [[MSIMainBoard alloc] initWithCpuHoles:939];
}
@end

// 装机工程师的实现
@interface ComputerEngineer : NSObject
- (void)makeComputerWithSchema:(id<AbstractFactory>)schema;
@end

@interface ComputerEngineer ()
@property (nonatomic, strong) id<CPUApi> cpu;
@property (nonatomic, strong) id<MainBoardApi> mainBoard;
@end

@implementation ComputerEngineer
- (void)makeComputerWithSchema:(id<AbstractFactory>)schema {
	// 准备硬件
	[self prepareHardwaresWithSchema:schema];
	// 组装机器
	// 测试机器
}
- (void)prepareHardwaresWithSchema:(id<AbstractFactory>)schema {
	self.cpu = [schema createCpu];
	self.mainBoard = [schema createMainboard];
	
	// 测试是否好用
	[self.cpu calculate];
	[self.mainBoard installCPU];
}
@end

// 测试
int main(int argc, char * argv[]) {
	ComputerEngineer *engineer = [ComputerEngineer new];
	[engineer makeComputerWithSchema:[SchemaTwo new]];
}

```
### 定义可扩展的工厂
抽象工厂为每一种它能创建的产品对象定义了相应的方法，如果在产品簇中要新加一种产品，比如现在我们要加一个内存，那就需要在抽象工厂中添加创建内存的一个方法。当抽象工厂一发生变化，所有的具体工厂实现都要发成变化。
现在有一种相对灵活，但不太安全的改进方式可以解决问题：抽象工厂里面不需要定义那么多方法，定义一个方法，给这个方法设置一个参数，通过这个参数来判断具体创建什么产品对象。由于只有一个方法，在返回类型上就不能是具体某个产品类型了，只能是所有的产品对象都继承或者实现的这么一个类型，在Objective-C里面干脆就使用NSObject类型。示例代码如下：
```objc
// 抽象工厂的接口
@protocol AbstractFactory <NSObject>
- (NSObject *)createProductWithType:(NSUInteger)type;
@end

// 具体工厂1
@interface SchemaOne : NSObject<AbstractFactory>

@end
@implementation SchemaOne
- (NSObject *)createProductWithType:(NSUInteger)type {
	if (type == 1) {
		return [[IntelCPU alloc]initWithPins:1386];
	} else if (type == 2) {
		return [[GAMainBoard alloc]initWithCpuHoles:1386];
	} else {
		return nil;
	}
}
@end

// 具体工厂2
@interface SchemaTwo : NSObject<AbstractFactory>

@end
@implementation SchemaTwo
- (NSObject *)createProductWithType:(NSUInteger)type {
	if (type == 1) {
		return [[AMDCPU alloc]initWithPins:1386];
	} else if (type == 2) {
		return [[MSIMainBoard alloc]initWithCpuHoles:1386];
	} else {
		return nil;
	}
}
@end

// 装机工程师的实现
@interface ComputerEngineer : NSObject
- (void)makeComputerWithSchema:(id<AbstractFactory>)schema;
@end

@interface ComputerEngineer ()
@property (nonatomic, strong) id<CPUApi> cpu;
@property (nonatomic, strong) id<MainBoardApi> mainBoard;
@end

@implementation ComputerEngineer
- (void)makeComputerWithSchema:(id<AbstractFactory>)schema {
	// 准备硬件
	[self prepareHardwaresWithSchema:schema];
	// 组装机器
	// 测试机器
}
- (void)prepareHardwaresWithSchema:(id<AbstractFactory>)schema {
	// 这里需要强转类型，不安全
	self.cpu = (id<CPUApi>)[schema createProductWithType:1];
	self.mainBoard = (id<MainBoardApi>)[schema createProductWithType:2];
	
	// 测试是否好用
	[self.cpu calculate];
	[self.mainBoard installCPU];
}
@end

// 测试
int main(int argc, char * argv[]) {
	ComputerEngineer *engineer = [ComputerEngineer new];
	[engineer makeComputerWithSchema:[SchemaTwo new]];
}
```
上面强转类型，如果返回的不是CPU，强制转换成CPU就会发生错误，不安全。下面体验一下这种方式的灵活性，比如我们加内存，我们可以提供一个新的SchemaThree来使用它：
```objc
// 定义内存接口
@protocol MemoryApi <NSObject>
- (void)cacheData;
@end

// 内存具体实现
@interface HyMemory : NSObject<MemoryApi>

@end
@implementation HyMemory
- (void)cacheData {
	NSLog(@"内存充足");
}
@end

// 包含创建内存的具体工厂
@interface SchemaThree : NSObject<AbstractFactory>

@end
@implementation SchemaThree

- (NSObject *)createProductWithType:(NSUInteger)type {
	if (type == 1) {
		return [[IntelCPU alloc]initWithPins:1386];
	} else if (type == 2) {
		return [[GAMainBoard alloc]initWithCpuHoles:1386];
	} else if (type == 3) {
		return [HyMemory new];
	} else {
		return nil;
	}
}
@end

// 装机工程师的实现
@interface ComputerEngineer : NSObject
- (void)makeComputerWithSchema:(id<AbstractFactory>)schema;
@end

@interface ComputerEngineer ()
@property (nonatomic, strong) id<CPUApi> cpu;
@property (nonatomic, strong) id<MainBoardApi> mainBoard;
@end

@implementation ComputerEngineer
- (void)makeComputerWithSchema:(id<AbstractFactory>)schema {
	// 准备硬件
	[self prepareHardwaresWithSchema:schema];
	// 组装机器
	// 测试机器
}
- (void)prepareHardwaresWithSchema:(id<AbstractFactory>)schema {
	
	self.cpu = (id<CPUApi>)[schema createProductWithType:1];
	self.mainBoard = (id<MainBoardApi>)[schema createProductWithType:2];
	self.memory = (id<MemoryApi>)[schema createProductWithType:3];

	// 测试是否好用
	[self.cpu calculate];
	[self.mainBoard installCPU];
	// 这里需要加判断，如果不加判断，使用SchemaOne和SchemaTwo时会Crash
	if (self.memory) {
		[self.memory cacheData];
	}
}
@end

// 测试
int main(int argc, char * argv[]) {
	ComputerEngineer *engineer = [ComputerEngineer new];
	// 这里直接使用SchemaThree就好了
	[engineer makeComputerWithSchema:[SchemaThree new]];
}
```
这种方式比较灵活，当然也不太安全，是否使用要看设计上的权衡了。
### 思考抽象工厂模式
抽象工厂模式的本质是**选择产品簇的实现**，工厂方法是选择单个产品实现，虽然一个类里面可以有多个工厂方法，但是这些方法之间一般没有联系，即使看起来像有联系。但是抽象工厂着重的就是为一个产品簇选择实现，定义在抽象工厂里面的方法通常是有联系的，他们都是产品的某一个部分或者是相互依赖的。如果在抽象工厂里面只定义一个方法，直接创建产品，那么就退化成工厂方法了。如果把工厂类退化一下，只提供工厂方法，并且提供默认实现就退化成简单工厂了。
## 总结
简单工厂：选择实现，减少不必要的依赖，方便代码复用。

工厂方法：父类定框架，子类做实现，把选择实现延迟到子类，符合开闭原则，依赖倒置原则。

抽象工厂：创建产品簇，简化业务逻辑。
