---
layout: post
title: 如何用类族模式隐藏实现细节
date:   2015-09-24 14:20:25
tags: 读书笔记
categories: iOS 
---
​         类族是一种很有用的模式，可以隐藏“抽象基类”中的实现细节。这里的抽象基类是指在这个类中只提供接口，并没有提供实现细节，通常是子类重写这个接口，来实现其中的细节。OC中的系统框架普遍应用这个模式。下面我们来举个例子，iOS中有个UIButton的类，想要创建一个按钮，需要调用下面这个方法：
<!-- more -->

```objective-c
+ (instancetype)buttonWithType:(UIButtonType)buttonType;
```

​           该方法返回的对象，其类型取决于传入的按钮类型。然而不管返回什么类型的对象，他们都继承自同意基类，就是UIButton。这么做的意义在于，UIButton类的使用者无需关心创建出来的按钮具体属于哪个子类，也不用考虑按钮的绘制方式等实现细节。使用者只需知道如何创建按钮，怎么设置title这样的属性，怎么增加监听动作的目标对象等问题就好。

​        回到开头说的问题，我们可以把各种按钮的绘制逻辑都放在一个类里面，并根据类型来切换：

```objective-c
-(void)drawRect:(CGRect)rect{
    if (_type = TypeA) {
        //绘制TypeA类型button
    }else if (_type = TypeB){
        //绘制TypeB类型button
    }/*.......*/
}
```

​        这样写上去还算简单，但是，如果需要依按钮类型来切换的绘制方法有很多，那么就会很麻烦。优秀的开发者会将这种代码重构为多个子类，把各个按钮所用的绘制方法放到相关子类中去，不过这么做需要用户知道各种子类才行。此时就应该用类族模式，该模式可以灵活应对多个类，将他们的实现细节隐藏在抽象基类后面，一遍保持接口的简洁。用户无需自己创建子类实例，只需调用基类方法即可。

​         下面我们来讲一下如何创建类族。假设有一个处理雇员的类，每个雇员有名字和薪水两个属性，管理者可以命令其执行日常工作。但是，各种雇员的工作内容不同，经理在带领团队做项目时，无需关心每个人如何完成任务的，仅需指示其开工即可。

​        首先，我们要定义抽象基类：

```objective-c
typedef NS_ENUM(NSUInteger,EmployeeType){
    EmployeeTypeDeveloper,
    EmployeeTypeDesigner,
};
@interface Employee : NSObject
@property (nonatomic, copy) NSString *name;
@property (nonatomic, assign) NSUInteger salary;
//创建雇员对象方法
+(Employee *)emploeeWithType:(EmployeeType)type;
//让雇员工作
-(void)doADaysWork;
@end
@implementation Employee
+(Employee *)emploeeWithType:(EmployeeType)type{
    switch (type) {
        case EmployeeTypeDesigner:
            return [EmployeeDesigner new];
            break;
            
        case EmployeeTypeDeveloper:
            return [EmployeeDeveloper new];
            break;
    }
}
-(void)doADaysWork{
    //子类实现
}
@end
```

​          每个实体子类都是从基类继承而来，比如：

```objective-c
@interface EmployeeDeveloper : Employee
@end

@implementation EmployeeDeveloper
-(void)doADaysWork{
    [self writeCode];
}
-(void)writeCode{
    NSLog(@"writeCode");
}
@end
```

​        在本例中，基类实现了一个类方法，该方法根据带创建的雇员类别分配好对应的雇员类实例。这种“工厂模式”是创建类族的办法之一。

​        因为OC这门语言没办法指明某个基类是抽象的。于是，开发者通常会在文档中写明类的用法。这种情况下，一般基类接口都没有名为init的方法，这暗示该类的实例不应该由用户自己直接创建。还有一种方法可以确保用户不会使用基类实例，那就是在基类的`doADaysWork`方法中抛出异常，这种方法非常极端，很少人用。

​        如果对象所属的类位于某个类族中，那么在查询类型信息时就要当心了。你可能会觉得创建了某个类的实例，但是实际上创建的是其子类的实例，在上面这个类里面，`[employee isMemberOfClass:[Employee class]]`这个方法似乎会返回YES，但实际上却是NO，因为employee并非Employee类的实例，而是其子类的实例。

​         下面再来说一下Cocoa里面的类族，系统框架中有许多类族，大部分Collection都是类族，例如NSArray和NSMutableArray。这样看来实际上有两个抽象基类，一个用于可变数组，一个用于不可变数组。尽管具备公共接口的类有两个，但是仍然可以算作一个类族，只是不可变数组定义了所有数组都通用的接口，而可变数组仅仅定义了可变数组需要的接口。这意味着两者可以在实现各自类型的数组时可以共用实现代码，此外还可以把可变数组拷贝为不可变，反之亦然。

​        在使用NSArray的alloc方法来获取实例时，该方法首先会分配一个属于某类的实例，此实例充当站位数组。该数组稍后会转为另一个类的实例，而那个类就是NSArray的实体子类。这个过程稍显复杂，我们就不讨论了。

​        像NSArray这样的类背后其实是个类族，明白这一点很重要，否则几可能写出下面这种代码：

```objective-c
id maybeAnArray = /* ... */;
if ([maybeAnArray class] == [NSArray class]) {
     //永远不会执行
 }
```

​         因为NSArray是个类族，其中if语句永远不可能为真，`[maybeAnArray class]`所返回的类绝不是NSArray本身，因为NSArray的初始化方法所返回的那个实例其类型是隐藏在类族公共接口后面的某个内部类型。

​        不过，仍然有办法可以判断出某个实例所属的类是否位于类族中。我们不用刚才的写法，而是用类型信息查询方法，若想判断某对象是否位于类族中，不要直接检测两个类对象是否相等，而应该用下面这种方法：

```objective-c
id maybeAnArray = /* ... */;
 if ([maybeAnArray isKindOfClass:[NSArray class]]) {
            //会执行
  }
```

​        我们经常需要向类族中新增实体子类，不过这么做的时候要小心，在Employee这个例子中，若是没有工厂方法的源代码，那就无法向其中新增雇员类别了。然而对于cocoa中NSArray这样的类族来说，还是有办法新增子类的，但是需要遵守几条规则：

1. 子类应该继承自类族中的抽象基类。

   若要编写NSArray类族的子类，需要令其继承自不可变数组的基类或者可变数组的基类。

2. 子类应该定义自己的数据存储方式

   我们在编写NSArray子类时，经常在这个问题上受阻。子类必须用一个实例变量来存放数组中的对象，这似乎和大家预想的不同，我们以为NSArray肯定会自己保存那些对象，所以无需再子类中再存一份了。但是，我们要记住，NSArray本身只不过时报在其他隐藏对象外面的壳，他仅仅定义了所有数组都具备的一些接口。对于这个自定义数组子类来说，可以用NSArray来保存其实例。

3. 子类应该重写超类文档中指明需要重写的方法。

	在每个抽象基类中，都有一些子类需要重写的方法。比如说，想要编写NSArray的子类，就需要实现count和objectAtIndex方法。像lastObject这种方法就无须实现了，因为基类可以根据前两个方法实现出这个方法。

   在类族中实现子类所需的遵循规范一般都定义在基类的文档中，编码是应该先看看。

---- 

   接下来总结下：

   * 类族模式可以把实现细节隐藏在一套简单的公共接口后面。
   * 系统框架中经常使用类族。
   * 从类族的公共抽象基类中继承子类时要小心，如果有开发文档，应该先看开发文档

	   ​

	   ​

	   ​

	   ​

	  
	​

